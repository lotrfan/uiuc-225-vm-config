#!/usr/bin/env sh

# Returns the shell executing the current script
shell () {
  local SHELL;
  SHELL="$(basename "$(ps hp $$ | grep "$$" | awk '{print $5}' | sed 's/-//')")"
  basename "$(readlink -f "$(which $SHELL)")"
}

# Determines the top level configuration directory
dir_try () {
  cd "$(dirname "$(readlink -f "$1")")" 2>/dev/null || return 1
  DIR_CONF="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
  echo "$DIR_CONF"
}
dir_conf () {(
    dir_try "$1" && return 0
    dir_try "$HOME/.zshrc" && return 0
    dir_try "$HOME/.bashrc" && return 0
    dir_try "$HOME/.xinitrc" && return 0
    echo "Failed to find the configuration directory" >&2
    return 1
)}

# Loads the shell specific fixes
. "$(dir_conf "$0")/lib/fixes.$(shell)" 2>/dev/null || {
  echo "Failed to load the fixes for the current shell" >&2
  exit 1
}

# Allows the functions to be reloaded at any time
reload_all () {
  . "$(dir_conf)/lib/loader"
}

# Source Modules
load_all () {
  [ "$#" -ge "1" ] || return 1
  local DIRCONF; local MODS;
  DIRCONF="$(dir_conf "$0")" || return 1
  to_array MODS "$(find "$DIRCONF/$1" -type f)"
  for M in $MODS; do
    [ "$(echo "$M" | grep '\(~$\|^#\)')" != "" ] && continue
    . "$M" || { echo "Failed to load module $M"; return 1; }
  done
}
load_all lib/mod

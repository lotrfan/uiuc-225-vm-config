#!/usr/bin/env sh

# Returns the shell executing the current script
shell () {
  local SHELL;
  SHELL="$(basename "$(ps hp $$ | grep "$$" | awk '{print $5}' | sed 's/-//')")"
  basename "$(readlink -f "$(which $SHELL)")"
}

# Determines the top level configuration directory
dir_try () {
  DIR_BIN="$(readlink -f "$1" 2>/dev/null)" || return 1
  cd "$(dirname "$DIR_BIN")" 2>/dev/null || return 1
  DIR_CONF="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
  echo "$DIR_CONF"
}
dir_conf () {(
    dir_try "$1" && return 0
    dir_try "$HOME/.zshrc" && return 0
    dir_try "$HOME/.bashrc" && return 0
    dir_try "$HOME/.xinitrc" && return 0
    echo "Failed to find the configuration directory" >&2
    return 1
)}

# Loads the shell specific fixes
. "$(dir_conf "$0")/lib/fixes.$(shell)" 2>/dev/null || {
  echo "Failed to load the fixes for the current shell" >&2
  exit 1
}

# Extra array functions for accessor simplicity
array_empty () {
  [ "$(array_size $1)" -eq "0" ]
}
array_forall () {
  for I in $(seq 0 $(expr $(array_size $1) - 1)); do
    eval "$2 \"$(array_at $1 $I)\"" || return 1
  done
}

# Allows the functions to be reloaded at any time
reload_all () {
  . "$(dir_conf)/lib/loader"
}

# Source Modules
load_one () {
  [ "$(echo "$1" | grep '\(~$\|^#\)')" != "" ] && return 0
  . "$1" || { echo "Failed to load module $1"; return 1; }
}
load_all () {
  [ "$#" -ge "1" ] || return 1
  local DIRCONF; local MODS;
  DIRCONF="$(dir_conf "$0")" || return 1
  array_from_str MODS "$(find "$DIRCONF/$1" -type f)"
  array_forall MODS load_one
}
load_all lib/mod

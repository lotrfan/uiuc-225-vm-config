#!/usr/bin/env sh

# Run the command silently
run_quiet () {
  which $1 >/dev/null 2>&1 && $@ >/dev/null 2>&1
}

# Make sure the symbolic link points to the correct location $2 -> $1
symlink () {
  if [ "$(readlink -f "$2")" != "$1" ]; then
    rm -rf "$2"
    ln -s "$1" "$2" 2>/dev/null || return 1
  fi
}

# Get the path to the temporary directory
dir_tmp () {
  local DIR_TMP
  dir_tmp_tryall
  [ "$DIR_TMP" = "" ] && { echo "Failed to find a temporary folder" >&2; return 1; }
  [ ! -d "$DIR_TMP" ] && mkdir "$DIR_TMP" && chmod 0700 "$DIR_TMP"
  symlink "$DIR_TMP" "$HOME/.tmp"
  echo "$DIR_TMP"
}
dir_tmp_tryall() {
  dir_tmp_one "/dev/shm" && return 0
  dir_tmp_one "/run/shm" && return 0
  dir_tmp_one "/tmp" && return 0
  dir_tmp_one "/var/tmp" && return 0
}
dir_tmp_one () {
	[ -w "$1" ] || return 1
  mount | grep '\(tmpfs\|ramfs\)' | grep $1 >/dev/null || return 1
  DIR_TMP="$1/$USER"
}

# Tests to see if a binary exists in the path
path_hasbin () {
  [ "$#" -ne "1" ] && return 2
  [ "$(/usr/bin/which $1 2>/dev/null | grep -v "not found")" != "" ]
}

# Checks to see if the process is running
proc_exists () {
  [ "$#" -ne "1" ] && return 1
  kill -0 $1 >/dev/null 2>&1
}

# Checks the pidfile to see if the process is running
check_pidfile () {
  [ -f "$1" ] && proc_exists "$(cat $1 2>/dev/null)"
}

# Add to the path if the DIR doesn't exist
path_add () {
  if [ "$(echo "$PATH" | grep "$1" 2>/dev/null)" = "" ]; then
    export PATH="${PATH}:$1"
  fi
}

# Wraps the command in sudo if sudo exists and runs it
sudo_wrap () {
  if path_hasbin sudo; then
    sudo $@
  else
    $@
  fi
}
